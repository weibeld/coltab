#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say);
use File::Basename;
use HTML::TagTree;
use Getopt::Std;

our $VERSION = "0.1";
our $SCRIPT_NAME = basename($0);

# If set to true, exit script after processing --help or --version flags
$Getopt::Std::STANDARD_HELP_VERSION = 1;

# Command-line options
my %opts;
getopts('c:l', \%opts) or abort();
# These vars are true if and only if the corresponding options are specified
my $css = $opts{c};
my $is_link_css = $opts{l};

# Command-line positional arguments
@ARGV == 1 or abort("Error: incorrect number of arguments");
my $markdown = $ARGV[0];

# Do work
init_html();
set_css($css, $is_link_css) if ($css);
parse_file($markdown);
print get_html();

#------------------------------------------------------------------------------#
# Subroutines
#------------------------------------------------------------------------------#

# Called by Getopt::Std when supplying --help option
sub HELP_MESSAGE {
  stdo(get_help_message());
}

# Called by Getopt::Std when supplying --version or --help option
sub VERSION_MESSAGE {
  stdo_ln("$SCRIPT_NAME version $VERSION");
}

# Abort script due to error (e.g. invalid command-line options)
sub abort {
  my $msg = shift;
  stde_ln($msg) if ($msg);
  stde(get_help_message());
  exit 1;
}

# Get help message
sub get_help_message {
  return <<"EOF"
Usage:
  $SCRIPT_NAME [options] <markdown-file>

Options:
  -c <file>  CSS file
  -l         Only link to CSS file (rather than including it)
  --help     Show this screen
  --version  Show version information
EOF
}

# Print argument to stdout or stderr, respectively
sub stdo { print STDOUT shift; }
sub stde { print STDERR shift; }
sub stdo_ln { say STDOUT shift; }
sub stde_ln { say STDERR shift; }


#------------------------------------------------------------------------------#
# HTML Manager
#------------------------------------------------------------------------------#

# Implemented with HTML::TagTree

# Reading an entire file by memory mapping
use File::Map qw(map_file);
# Enable given-when statement and turn off warnings about it
use feature qw(switch);
no warnings 'experimental::smartmatch';

my $html;
my $head;
my $body;
my $table;

# Initialise a new HTML tree. Must be called before all other subroutines.
sub init_html {
  $html= HTML::TagTree->new('html');
  $head = $html->head();
  $body = $html->body();
}

# Add CSS information to HTML tree.
# Arguments:
#   $css:     a valid filename
#   $is_link: bool: true => add link to CSS file; false => include CSS content
sub set_css {
  my($css, $is_link) = @_;
  if ($is_link) {
    $head->link('', "rel=\"stylesheet\" href=\"$css\"");
  } else {
    map_file(my $css_content, $css);
    $head->style($css_content);
  }
}

# Add a title (<h1> to <h6>) to the HTML tree
sub add_title {
  my ($level, $text) = @_;
  given ($level) {
    when (1) { $body->h1($text); }
    when (2) { $body->h2($text); }
    when (3) { $body->h3($text); }
    when (4) { $body->h4($text); }
    when (5) { $body->h5($text); }
    when (6) { $body->h6($text); }
    default { die "Invalid HTML header level"; }
  }
}

# Add a new table to the HTML tree
sub start_new_table {
  $table = $body->table();
}

# Add a new row to the most recently added table of the HTML tree
sub add_table_row {
  my $color_code = shift;
  my $tr = $table->tr();
  $tr->td('', "class=\"color\" style=\"background-color:$color_code\"");
  $tr->td($color_code, 'class="code"');
}

# Return the generated HTMl as a string
sub get_html{
  return $html->get_html_text(-1, 0);
}


#------------------------------------------------------------------------------#
# Parsing Manager
#------------------------------------------------------------------------------#

my $is_table_started;

sub parse_file {
  my $fname = shift;
  open(my $f, '<', $fname) or die "Can't open file $fname for reading: $!";
  # Loop through all the lines of the input file
  while (<$f>) {
    next if parse_list_item($_);
    # If it's not a list item and there's an open table, close the table
    if ($is_table_started) { $is_table_started = 0; }
    next if parse_title($_);
  }
}

sub parse_list_item {
  my $line = shift;
  # Test if the line is a list item
  if ($line =~ /^[*+-]\s+`?\#?([a-f0-9]{3}|[a-f0-9]{6})`?\s*$/i) {
    if (not $is_table_started) {
      start_new_table();
      $is_table_started = 1;
    }
    add_table_row("#$1");
    return 1;
  }
}

sub parse_title {
  my $line = shift;
  if (is_title($line)) {
    my %title = get_title($line);
    add_title($title{level}, $title{text});
    return 1;
  }
}

sub get_title {
  my $line = shift;
  for my $i (1 .. 6) {
    my $pattern = "^" . "#"x$i . "\\s+(.*)\$";
    if ($line =~ /$pattern/) {
      return (level => $i, text => $1);
    }
  }
}

sub is_title {
  my $line = shift;
  return ($line =~ /^#{1,6}\s/);
}

